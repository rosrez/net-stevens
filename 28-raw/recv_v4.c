/* 
 * Stevens, 28.20
 * recv_v4() function: rads and processes ICMPv4 messages.
 */
#include "trace.h"

extern int gotalarm;

/*
 * Return:  -3 on timeout
 *          -2 on ICMP time exceeded in transit (caller keeps going)
 *          -1 on ICMP port unreachable (caller is done)
 *        >= 0 return value is some other ICMP unreachable code
 */

/*
 * SET ALARM AND READ EACH ICMP MESSAGE
 * An alarm is set for three seconds into the future and the function enters a loop
 * that calls recvfrom(), reading each ICMPv4 message returned on the raw socket.
 * This function avoids the race condition we described in Section 20.5 by using
 * a global flag.
 *
 * GET POINTER TO ICMP HEADER
 * ip points to the beginning of the IPv4 header (recall that a raw socket always
 * returns the IP header), and icmp points to the beginning of the ICMP header.
 *
 * PROCESS ICMP "TIME EXCEEDED IN TRANSIT" MESSAGE
 * If the ICMP message is a "time exceeded in transit" message, it is possibly a reply
 * to one of our probes. hip points to the IPv4 header that is returned in the ICMP
 * message following the 8-byte ICMP header. udp points to the UDP header that follows.
 * If the ICMP message was generated by a UDP datagram and if the source and destination
 * ports of that datagram are the values we sent, then this is a reply to our probe
 * from an intermediate router.
 *
 * PROCESS ICMP "PORT UNREACHABLE" MESSAGE
 * If the ICMP message is "destination unreachable", then we look at the UDP header
 * returned in the ICMP message to see if the message is a response to our probe.
 * If so, and the ICMP code is "port unreachable", we return -1 as we have reached
 * the final destination. If the ICMP message is from one of our probes but it is not a
 * "port unreachable", then that ICMP code value is returned. A common example of
 * this is a firewall returning some other unreachable code for the destination host
 * we are probing.
 */

int recv_v4(int seq, struct timeval *tv)
{
    int hlen1, hlen2, icmplen, ret;
    socklen_t len;
    ssize_t n;
    struct ip *ip, *hip;
    struct icmp *icmp;
    struct udphdr *udp;

    gotalarm = 0;
    alarm(3);
    for ( ; ; ) {
        if (gotalarm)
            return -3;              /* alarm expired */
        
        len = pr->salen;
        n = recvfrom(recvfd, recvbuf, sizeof(recvbuf), 0, pr->sarecv, &len);
        if (n < 0) {
            if (errno == EINTR)
                continue;
            else
                err_sys("recvfrom() error");
        }

        ip = (struct ip *) recvbuf;         /* start of IP header */
        hlen1 = ip->ip_hl << 2;             /* length of IP header in bytes (encoded in 4-byte units) */

        icmp = (struct icmp *) (recvbuf + hlen1);           /* start of ICMP header */
        if ((icmplen = n - hlen1) < 8)
            continue;                       /* not enough to look at ICMP header */

        if (icmp->icmp_type == ICMP_TIMXCEED && icmp->icmp_code == ICMP_TIMXCEED_INTRANS) {
            if (icmplen < 8 + sizeof(struct ip))
                continue;               /* not enough data to look at inner IP */

            hip = (struct ip *)(recvbuf + hlen1 + 8);
            hlen2 = hip->ip_hl << 2;
            if (icmplen < 8 + hlen2 + 4)
                continue;                   /* not enough data to look at UDP ports */

            udp = (struct udphdr *) (recvbuf + hlen1 + 8 + hlen2);
            if (hip->ip_p == IPPROTO_UDP &&
                    udp->source == htons(sport) &&                              /* BSD: udp->uh_sport */
                    udp->dest == htons(dport + seq)) {                          /* BSD: udp->uh_dport */
                ret = -2;                   /* we hit an intermediate router */
                break;
            }
        } else if (icmp->icmp_type == ICMP_UNREACH) {
            if (icmplen < 8 + sizeof(struct ip))
                continue;                   /* not enough data to look at inner IP */

            hip = (struct ip *) (recvbuf + hlen1 + 8);
            hlen2 = hip->ip_hl << 2;
            if (icmplen < 8 + hlen2 + 4)
                continue;                   /* not enough data to looko at UDP ports */

            udp = (struct udphdr *) (recvbuf + hlen1 + 8 + hlen2);
            if (hip->ip_p == IPPROTO_UDP &&
                    udp->source == htons(sport) &&                              /* BSD: udp->uh_sport */
                    udp->dest == htons(dport + seq)) {                          /* BSD: udp->uh_dport */
                if (icmp->icmp_code == ICMP_UNREACH_PORT)
                    ret = -1;               /* have reached destination */
                else
                    ret = icmp->icmp_code;  /* 0, 1, 2, ... */
                break;
            }
        }

        if (verbose) {
            printf(" (from %s: type = %d, code = %d\n",
                    sock_ntop_host(pr->sarecv, pr->salen),
                    icmp->icmp_type, icmp->icmp_code);
        }

        /* Some other ICMP error, recvfrom() again */
    }

    alarm(0);           /* don't leave alarm running */
    gettimeofday(tv, NULL);
    return ret;
}
